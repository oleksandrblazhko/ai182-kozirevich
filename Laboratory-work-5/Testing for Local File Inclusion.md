## Тестування на включення локального файлу
### Короткі відомості
Уразливість File Inclusion дозволяє зловмиснику включити файл, зазвичай використовуючи механізми «динамічного включення файлу», реалізовані в цільовій програмі. Уразливість виникає через використання введених користувачем даних без належної перевірки.

Це може призвести до чогось схожого на виведення вмісту файлу, але залежно від серйозності це також може призвести до:

- Виконання коду на веб-сервері
- Виконання коду на стороні клієнта, наприклад JavaScript, що може призвести до інших атак, наприклад міжсайтового сценарію (XSS)
- Відмови в обслуговуванні (DoS)
- Розкриття конфіденційної інформації
- Включення локальних файлів (також відоме як LFI) — це процес включення файлів, які вже локально присутні на сервері, шляхом використання вразливих процедур включення, реалізованих у програмі. Ця вразливість виникає, наприклад, коли сторінка отримує як вхідні дані шлях до файлу, який потрібно включити, і цей вхід не очищається належним чином, що дозволяє вставляти символи обходу каталогу (наприклад, крапка-крапка-коса риска). Хоча більшість прикладів вказують на вразливі сценарії PHP, ми повинні мати на увазі, що це також поширене в інших технологіях, таких як JSP, ASP та інші.
### Як тестувати
Оскільки LFI виникає, коли шляхи, передані операторам включення, не очищаються належним чином, у підході тестування чорної скриньки ми повинні шукати сценарії, які приймають імена файлів як параметри.

Розглянемо такий приклад:
```
http://vulnerable_host/preview.php?file=example.html
```
Це виглядає як ідеальне місце, щоб спробувати LFI. Якщо зловмиснику пощастить, і замість вибору відповідної сторінки з масиву за її іменем, скрипт безпосередньо включає вхідний параметр, можна включити довільні файли на сервері.

Типовим підтвердженням концепції було б завантажити файл passwd:
```
http://vulnerable_host/preview.php?file=../../../../etc/passwd
```
Якщо зазначені вище умови виконуються, зловмисник побачить приблизно таке:
```root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
alex:x:500:500:alex:/home/alex:/bin/bash
margo:x:501:501::/home/margo:/bin/bash
...
```
Навіть якщо існує така вразливість, її використання може бути більш складним у реальних сценаріях. Розглянемо наступний фрагмент коду:
```
<?php include($_GET['файл'].".php"); ?>
```
Проста заміна файлу випадковим іменем працювати не буде, так як до наданого вводу додається постфікс .php. Щоб отримати його, тестер може використовувати кілька методів, щоб отримати очікувану експлуатацію.

### Введення нулевого байту
Нулевий символ (також відомий як нульовий термінатор або нулевий байт) — це керуючий символ зі значенням ноль, присутній у багатьох наборах символів, який використовується в якості зарезервованого символу для позначення кінця рядка. Після використання будь-якого символу після цього спеціального байту буде ігноруватися. Зазвичай цей символ вводиться за допомогою закодованої строки URL %00 шляхом додавання її до запрошеного шляху. У нашому попередньому прикладі виконання запиту до ```http://vulnerable_host/preview.php?file=../../../../etc/passwd%00``` ігноровано шляхом розширення .php, додане до імені вхідного файлу. , повертає злоумышленнику список основних користувачів в результаті успішної експлуатації.

### Усечення шляху і точки
У більшості інсталяцій PHP обмеження імені файлу становить 4096 байт. Якщо яке-небудь задане ім'я файлу довше цієї довжини, PHP його просто усує, видаляючи будь-які додаткові символи. Зловживання цією поведінкою дозволяє механізму PHP ігнорувати розширення .php, переміщуючи його за межі 4096 байт. Коли це відбувається, помилка не виникає; додаткові символи просто відбрасуються, і PHP продовжує працювати в звичайному режимі.

Цей обхід зазвичай поєднується з іншими стратегіями логічного обходу, наприклад, як кодування частин шляху до файлу з кодуванням Unicode, введенням подвійного кодування або іншого вводу, який, як і раніше, представлятиме допустиме бажане ім’я файлу.

### PHP-обертки
Уразливості включення локальних файлів зазвичай розглядаються як уразливості лише для чтення, які зловмисник може використовувати для чтення конфіденційних даних із сервера, на якому розміщено вразливе додаток. Однак у деяких конкретних реалізаціях цієї вразливості можна використовувати для оновлення атак з LFI до уразливостей видаленого коду виконання, які потенційно можуть повністю скомпрометувати хост.

Це вдосконалення часто використовується, коли зловмисник може комбінувати вразливість LFI з певною оболонкою PHP.

Обертка — це код, який окружає інший код для виконання деяких додаткових функцій. PHP реалізує безліч вбудованих оболочок для використання з функціями файлової системи. Як тільки їх використання виявлено в процесі тестування додатків, рекомендується спробувати зловживати ними, щоб визначити реальний ризик виявлених недоліків. Нижче ви можете отримати список найбільш часто використовуваних оболонок, хоча ви повинні врахувати, що він не є вичерпним, і в той же час можна зареєструвати користувацькі оболонки, які, якщо вони відповідають цілям, вимагають більш глибокого спеціального аналізу.

### PHP-фільтр
Використовується для доступу до локальної файлової системи; це нечутлива до реєстру оболонка, яка дозволяє застосовувати фільтри до потоку під час відкриття файлу. Цю оболонку можна використовувати для отримання вмістимого файлу, що передує його виконанню сервером. Наприклад, дозволяє зловмиснику читати містяться файли PHP, щоб отримати вихідний код для ідентифікації конфіденційної інформації, такої як учетні дані або інші уразливості, які можна використовувати.

Оболочку можна використовувати як ```php://filter/convert.base64-encode/resource=FILE```, де ```FILE``` — це файл для вилучення. У результаті цього використання виконання містить цільовий файл буде прочитано, закодовано в base64 (той крок, який передбачає виконання на стороні сервера) і повернуто агенту користувача.

### ZIP-файл PHP
У PHP 7.2.0 була введена оболонка zip:// для керування стиснутими zip-файлами. Ця оболонка містить наступні структурні параметри: ```zip:///filename_path#internal_filename```, де filename_path — це шлях до шкідливого файлу, a internal_filename — це шлях, за яким корисний файл знаходиться всередині оброблюваного ZIP-файлу. Під час експлуатації зазвичай # кодується значенням URL-адреса в кодуванні %23.

Зловживання цією оболонкою може створити шкідливий ZIP-файл зловмисника, який можна завантажити на сервер, наприклад, у вигляді зображення-аватара або за допомогою будь-якої системи завантаження файлів, доступних на цільовому веб-сайті (оболочка php:zip:// не вимагається, щоб zip-файл мав яке-небудь конкретне розширення) для виконання вразливості LFI.

Щоб протестувати цю вразливість, можна виконати наступну процедуру для атаки на наведений вище приклад коду.

Створіть виконуваний файл PHP, наприклад, із вмістом ```<?php phpinfo(); ?>``` і збережіть його як code.php
Зробіть його як новий ZIP-файл з іменем target.zip.
Перемістіть файл target.zip у target.jpg, щоб отримати перевірку розширення та завантажте його на цільовому веб-сайті в якості зображення аватари.
Покладіть, що файл target.jpg зберігається локально на сервері по шляху ```../avatar/target.jpg```, використовуйте чутливість за допомогою ZIP-оболочок PHP, що виводить наступну корисну завантаження на небезпечну URL-адресу: ``` zip://../avatar/target.jpg%23code``` (запам’ятайте, що %23 відповідає #).
Якщо в нашому зразку розширення .php пов’язано з нашою корисною завантаженням, запит до ```http://vulnerable_host/preview.php?file=zip://../avatar/target.jpg%23code``` приведе до виконання code.php, існуючий у корисному ZIP-файлі.

### PHP-дані
Ця оболонка, доступна починаючи з PHP 5.2.0, передбачає наступне використання: ```data://text/plain;base64,BASE64_STR```, де BASE64_STR — закодований у Base64 вміст оброблюваного файлу. Важливо враховувати, що ця оболонка буде доступна тільки в тому випадку, якщо буде включена опція ```allow_url_include```.

Щоб протестувати LFI за допомогою цієї оболонки, виконуваний код повинен бути закодований у Base64, наприклад, ```<?php phpinfo(); ?>``` код буде закодовано як: PD9waHAgcGhwaW5mbygpOyA/Pg== тому завантаження матиме вид: ```data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==```.

### Очікування від PHP
Ця оболонка, яка не включена за умовчанням, забезпечує доступ до процесів stdio, stdout і stderr. Очікуючи використання в якості команди expect://, сервер виконує надану команду в BASH і повертає її результат.

### Виправлення
Найбільш ефективне рішення для усунення вразливостей, пов’язаних із включенням файлів, полягає в тому, щоб позбутися від передачі введених користувачів даних у будь-який API файлової системи/фреймворка. Якщо це неможливо, програма може підтримувати список файлів, які можуть бути дозволені на сторінці, а потім використовувати ідентифікатор (наприклад, порядковий номер) для доступу до вибраного файлу. Любий запит, що містить недопустимий ідентифікатор, повинен бути відхилений, таким чином, зловмисники не можуть маніпулювати шляхом.

Ознайомтеся з пам'яткою про завантаження файлів, щоб дізнатися про передові методи забезпечення безпеки по цій темі.
