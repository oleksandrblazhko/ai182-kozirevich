## Тестування на включення локального файлу
### Короткі відомості
Уразливість File Inclusion дозволяє зловмиснику включити файл, зазвичай використовуючи механізми «динамічного включення файлу», реалізовані в цільовій програмі. Уразливість виникає через використання введених користувачем даних без належної перевірки.

Це може призвести до чогось схожого на виведення вмісту файлу, але залежно від серйозності це також може призвести до:

- Виконання коду на веб-сервері
- Виконання коду на стороні клієнта, наприклад JavaScript, що може призвести до інших атак, наприклад міжсайтового сценарію (XSS)
- Відмови в обслуговуванні (DoS)
- Розкриття конфіденційної інформації
- Включення локальних файлів (також відоме як LFI) — це процес включення файлів, які вже локально присутні на сервері, шляхом використання вразливих процедур включення, реалізованих у програмі. Ця вразливість виникає, наприклад, коли сторінка отримує як вхідні дані шлях до файлу, який потрібно включити, і цей вхід не очищається належним чином, що дозволяє вставляти символи обходу каталогу (наприклад, крапка-крапка-коса риска). Хоча більшість прикладів вказують на вразливі сценарії PHP, ми повинні мати на увазі, що це також поширене в інших технологіях, таких як JSP, ASP та інші.
### Як тестувати
Оскільки LFI виникає, коли шляхи, передані операторам включення, не очищаються належним чином, у підході тестування чорної скриньки ми повинні шукати сценарії, які приймають імена файлів як параметри.

Розглянемо такий приклад:
```
http://vulnerable_host/preview.php?file=example.html
```
Це виглядає як ідеальне місце, щоб спробувати LFI. Якщо зловмиснику пощастить, і замість вибору відповідної сторінки з масиву за її іменем, скрипт безпосередньо включає вхідний параметр, можна включити довільні файли на сервері.

Типовим підтвердженням концепції було б завантажити файл passwd:
```
http://vulnerable_host/preview.php?file=../../../../etc/passwd
```
Якщо зазначені вище умови виконуються, зловмисник побачить приблизно таке:
```root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
alex:x:500:500:alex:/home/alex:/bin/bash
margo:x:501:501::/home/margo:/bin/bash
...
```
Даже если такая уязвимость существует, ее использование может быть более сложным в реальных сценариях. Рассмотрим следующий фрагмент кода:
```
<?php include($_GET['файл'].".php"); ?>
```
Простая замена случайным именем файла не будет работать, так как к предоставленному вводу добавляется постфикс .php. Чтобы обойти его, тестер может использовать несколько методов, чтобы получить ожидаемую эксплуатацию.

### Введение нулевого байта
Нулевой символ (также известный как нулевой терминатор или нулевой байт) — это управляющий символ со значением ноль, присутствующий во многих наборах символов, который используется в качестве зарезервированного символа для обозначения конца строки. После использования любой символ после этого специального байта будет игнорироваться. Обычно этот символ вводится с помощью закодированной строки URL %00 путем добавления ее к запрошенному пути. В нашем предыдущем примере выполнение запроса к ```http://vulnerable_host/preview.php?file=../../../../etc/passwd%00``` игнорировало бы расширение .php, добавляемое к имени входного файла. , возвращая злоумышленнику список основных пользователей в результате успешной эксплуатации.

### Усечение пути и точки
В большинстве инсталляций PHP ограничение на имя файла составляет 4096 байт. Если какое-либо заданное имя файла длиннее этой длины, PHP просто усекает его, отбрасывая любые дополнительные символы. Злоупотребление этим поведением позволяет механизму PHP игнорировать расширение .php, перемещая его за пределы 4096 байт. Когда это происходит, ошибка не возникает; дополнительные символы просто отбрасываются, и PHP продолжает выполняться в обычном режиме.

Этот обход обычно сочетается с другими стратегиями логического обхода, такими как кодирование части пути к файлу с кодировкой Unicode, введение двойного кодирования или любой другой ввод, который по-прежнему будет представлять допустимое желаемое имя файла.

### PHP-обертки
Уязвимости включения локальных файлов обычно рассматриваются как уязвимости только для чтения, которые злоумышленник может использовать для чтения конфиденциальных данных с сервера, на котором размещено уязвимое приложение. Однако в некоторых конкретных реализациях эту уязвимость можно использовать для обновления атаки с LFI до уязвимостей удаленного выполнения кода, которые потенциально могут полностью скомпрометировать хост.

Это усовершенствование часто используется, когда злоумышленник может комбинировать уязвимость LFI с определенными оболочками PHP.

Обертка — это код, который окружает другой код для выполнения некоторых дополнительных функций. PHP реализует множество встроенных оболочек для использования с функциями файловой системы. Как только их использование обнаружено в процессе тестирования приложения, рекомендуется попытаться злоупотребить им, чтобы определить реальный риск обнаруженных недостатков. Ниже вы можете получить список с наиболее часто используемыми оболочками, хотя вы должны учитывать, что он не является исчерпывающим, и в то же время можно зарегистрировать пользовательские оболочки, которые, если они будут использоваться целью, потребуют более глубокого специального анализа.

### PHP-фильтр
Используется для доступа к локальной файловой системе; это нечувствительная к регистру оболочка, которая позволяет применять фильтры к потоку во время открытия файла. Эту оболочку можно использовать для получения содержимого файла, предотвращающего его выполнение сервером. Например, позволяя злоумышленнику читать содержимое файлов PHP, чтобы получить исходный код для идентификации конфиденциальной информации, такой как учетные данные или другие уязвимости, которые можно использовать.

Оболочку можно использовать как ```php://filter/convert.base64-encode/resource=FILE```, где ```FILE``` — это файл для извлечения. В результате использования этого выполнения содержимое целевого файла будет прочитано, закодировано в base64 (это шаг, который предотвращает выполнение на стороне сервера) и возвращено агенту пользователя.

### ZIP-файл PHP
В PHP 7.2.0 была введена оболочка zip:// для управления сжатыми zip-файлами. Эта оболочка ожидает следующую структуру параметров: ```zip:///filename_path#internal_filename```, где filename_path — это путь к вредоносному файлу, а internal_filename — это путь, по которому вредоносный файл находится внутри обрабатываемого ZIP-файла. Во время эксплуатации обычно # кодируется значением URL Encoded %23.

Злоупотребление этой оболочкой может позволить злоумышленнику создать вредоносный ZIP-файл, который можно загрузить на сервер, например, в качестве изображения аватара или с помощью любой системы загрузки файлов, доступной на целевом веб-сайте (оболочка php:zip:// не требуют, чтобы zip-файл имел какое-либо конкретное расширение) для выполнения уязвимостью LFI.

Чтобы протестировать эту уязвимость, можно выполнить следующую процедуру для атаки на приведенный выше пример кода.

Создайте исполняемый файл PHP, например, с содержимым ```<?php phpinfo(); ?>``` и сохраните его как code.php
Сожмите его как новый ZIP-файл с именем target.zip.
Переименуйте файл target.zip в target.jpg, чтобы обойти проверку расширения, и загрузите его на целевой веб-сайт в качестве изображения аватара.
Предположим, что файл target.jpg хранится локально на сервере по пути ```../avatar/target.jpg```, используйте уязвимость с помощью ZIP-оболочки PHP, внедрив следующую полезную нагрузку на уязвимый URL-адрес: ```zip://../avatar/target.jpg%23code``` (помните, что %23 соответствует #).
Поскольку в нашем образце расширение .php связано с нашей полезной нагрузкой, запрос к ```http://vulnerable_host/preview.php?file=zip://../avatar/target.jpg%23code``` приведет к выполнению code.php, существующий во вредоносном ZIP-файле.

### PHP-данные
Эта оболочка, доступная начиная с PHP 5.2.0, предполагает следующее использование: ```data://text/plain;base64,BASE64_STR```, где BASE64_STR — закодированное в Base64 содержимое обрабатываемого файла. Важно учитывать, что эта оболочка будет доступна только в том случае, если будет включена опция ```allow_url_include```.

Чтобы протестировать LFI с помощью этой оболочки, исполняемый код должен быть закодирован в Base64, например, ```<?php phpinfo(); ?>``` код будет закодирован как: PD9waHAgcGhwaW5mbygpOyA/Pg== поэтому полезная нагрузка будет иметь вид: ```data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==```.

### Ожидания от PHP
Это оболочка, которая не включена по умолчанию, предоставляет доступ к процессам stdio, stdout и stderr. Ожидая использования в качестве команды expect://, сервер выполнит предоставленную команду в BASH и вернет ее результат.

### Исправление
Наиболее эффективное решение для устранения уязвимостей, связанных с включением файлов, заключается в том, чтобы избегать передачи введенных пользователем данных в любой API файловой системы/фреймворка. Если это невозможно, приложение может поддерживать список разрешенных файлов, которые могут быть включены на страницу, а затем использовать идентификатор (например, порядковый номер) для доступа к выбранному файлу. Любой запрос, содержащий недопустимый идентификатор, должен быть отклонен, таким образом, злоумышленники не могут манипулировать путем.

Ознакомьтесь с памяткой по загрузке файлов, чтобы узнать о передовых методах обеспечения безопасности по этой теме.
